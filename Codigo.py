# -*- coding: utf-8 -*-
"""T1 Entregale.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17F1l1_RvlKowzsOgMQ-eCAKBWg5KxQS7
"""

#importar los archivos en carpeta gzip
###############################################################
#                      Authors:                               #
#                  Carlos Coronado                            #
#                  Adrián Monge                               #
#                   ITCR MT 8004                              #
#   Red neuronal convolucional: Clasificacion de caracteres   #
###############################################################

# Inicialización del entonrno e importación de librerías

from google.colab import drive  #Librería para accesar a archivos drive
import os  #Librería manejo del sistema

# Montar el archivo del drive (con previa autorización del usuario)
drive.mount('/content/drive', force_remount=True)

# Abrir el documento con la ruta de acceso personal predeterminada.
os.chdir("/content/drive/MyDrive/Sistemas_V/T1_Principios_imagen")

import numpy as np  #librería trabajo matrices
import matplotlib.pyplot as plt   #librería para graficar

from skimage.color import rgb2gray  #librería para converiar de color a escala gris
from PIL import Image          #Librería para trabajo de imagenes

image = Image.open('img_pruebas/colonia_30_cm.jpg') #Carga imagen en variable

new_image = image.resize((320, 240))   #Cambiar tamaño imagen

print(image.size) # salida tamaño imagen: (4608, 3456)
print(new_image.size) # salida tamaño imagen: (320, 240)

img_objeto = np.array(new_image)  # Se convierte imagen a arreglo

img_gray = rgb2gray(img_objeto)  #Valores de arreglo se pasan a escala gris
imgplot=plt.imshow(img_gray, cmap=plt.cm.gray) #se imprime imagen en gris
plt.xlabel("Posición en X (pixel)") #información de eje
plt.ylabel("Posición en Y (pixel)") #información de eje


plt.figure()       # Se genera el histograma

# Se pasa la infoación de la imagen como arreglo lineal
# es tabablecen 256 columnas, el rango de valor y los colores
plt.hist(img_gray.ravel(), bins=256, range=(0.0, 1.0), fc='k', ec='b')
plt.xlabel("Nivel de gris")       #información de eje
plt.ylabel("Cantidad de píxeles") #información de eje

print(img_objeto.shape)  # Forma imagen
print(img_gray.shape)    #Forma imagen en gris

#Se guardan los valores de ancho y alto de la imagen en gris
h = img_gray.shape[0]
w = img_gray.shape[1]


## Determinar únicamente el umbral segun histograma
a = 0.4


new_image = np.ones((h,w))# Se genera una matriz de unos para
#recorrer la imagen y binarizar los valores correspondientes al objeto
#según el valor de umbral
for i in range(h):# filas
    for j in range(w):# columnas
        if((img_gray[i,j]>= 0) and (img_gray[i,j]< a)): #si está en el rango
            new_image[i,j] = 0  # binariza pixel a cero

        else:
            new_image[i,j] = 1 # reasigna un 1


imgplot_BN=plt.imshow(new_image, cmap=plt.cm.gray) #imprime imagen binarizada
plt.xlabel("Posición en X (pixel)") #información de eje
plt.ylabel("Posición en Y (pixel)") #información de eje


plt.figure() #inicia histograma imagen binarizada

# Se pasa la infoación de la imagen como arreglo lineal
# es tabablecen 256 columnas, el rango de valor y los colores
plt.hist(new_image.ravel(), bins=256, range=(0, 1.0), fc='w', ec='k')
plt.xlabel("Nivel de gris")           #información de eje
plt.ylabel("Cantidad de píxeles")     #información de eje

import statistics #Funciones para estadistica

AnchoPerm = 32  #ancho de pixeles p

PorcImag = 30   #porcentaje de lineas a analizar +/- 15%

Pixe = np.round_(PorcImag*(240/100), decimals=0) #calculo cant lineas a usar

CentroMedic = 120    #Linea central de la imagen, punto de analisis

LimSup = int(CentroMedic - Pixe/2)   #limite superior lineas arriba

LimInf = int(CentroMedic + Pixe/2)   #limite superior lineas abajo

new_image2 = new_image[LimSup:LimInf,:] #nueva imagen con tamaño de lineas

imgplot_BN=plt.imshow(new_image2, cmap=plt.cm.gray)#imprime lineas seleccionadas
print(new_image2.shape) #forma imagen

#Ciclo que permite agregar linas con ancho permitido para calculo promedio
Valores = [] # arreglo de lineas
for j in range(new_image2.shape[0]):
  cont = 0 #contador ceros
  for i in range(new_image2.shape[1]):
    if new_image2[j][i] == 0: #si es cero suma al contador
      cont = cont+1
  if cont >= AnchoPerm : #si se supera ancho permicible se agrega la linea
    Valores.append(cont)



#Variables para calculo de lal ancho del objeto
dist_trab = 300   #300 mm distancia trabajo
ancho_sensor = 4.64 #ancho sensor mm
long_nueva = 320    # ancho pixeles imagen
dist_focal = 3.55   #distancia focal camara mm


#calculo de por relacion de ancho de pixeles en negro promedio de las lineas
ancho_sensor_en_negro = (ancho_sensor / long_nueva) * statistics.mean(Valores)

#conversion cantidad prom pixeles negro a longitud real
resultado = (dist_trab*ancho_sensor_en_negro)/ dist_focal

print(statistics.mean(Valores)) #imprime el promedio de pixeles 0 de las lineas
print("Distancia: ", resultado, " mm") #imprime resultado